{"version":3,"sources":["data-mapper/DataMapper.js"],"names":["DataMapper","query","schema","collection","lookup","serializeRow","queryRow","properties","schemata","relationshipType","keyCol","_keyColumnName","keyVal","doc","subProps","subSchemata","undefined","Schema","RELATIONSHIP_TYPE","MANY","i","length","convert","propertyName","columnName","push","document","_properties","_schemata","SINGLE"],"mappings":"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","sourcesContent":["/** Class that serializes a Schema into a normalized object. */\nclass DataMapper {\n    /**\n     * Serialize the query into the an array of objects, as defined by schema.\n     * @param {Object[]} query - A set of query results, which is an array of\n     * objects containing keys as properties and values from a database query.\n     * @param {Schema} schema - The Schema instance describing how to serialize the query.\n     * @return {Object[]} An array of objects that is normalized.\n     */\n    serialize(query, schema) {\n        const collection = [];\n        const lookup     = {};\n\n        // Helper function to recursively serialize a row of query data.\n        function serializeRow(queryRow, schema, collection, properties, lookup,\n                              schemata, relationshipType) {\n            const keyCol = schema._keyColumnName;\n            const keyVal = queryRow[keyCol];\n            let doc, subProps, subSchemata;\n\n            // The keyCol is null, meaning this was an outer join and there is no\n            // related data.\n            if (!keyVal)\n                return;\n\n            // First time encountering this key.  Create a document for it.\n            if (lookup[keyVal] === undefined) {\n                // If serializing to an array (a many relationship) then make a new\n                // document for this row, otherwise the data will be added directly to\n                // the collection.\n                if (relationshipType === Schema.RELATIONSHIP_TYPE.MANY)\n                    doc = {};\n                else\n                    doc = collection;\n\n                // Add each property->column value to the document.\n                for (let i = 0; i < properties.length; ++i) {\n                    if (properties[i].convert)\n                        doc[properties[i].propertyName] = properties[i].convert(queryRow[properties[i].columnName]);\n                    else\n                        doc[properties[i].propertyName] = queryRow[properties[i].columnName];\n                }\n\n                // Add the document to the collection (if serializing to an array).\n                if (relationshipType === Schema.RELATIONSHIP_TYPE.MANY)\n                    collection.push(doc);\n\n                // This lookup is used to ensure uniqueness.\n                lookup[keyVal] = {\n                    document: doc,\n                    lookup:   {}\n                };\n            }\n            else\n                doc = lookup[keyVal].document;\n\n            // Now serialize each sub schema.\n            for (let i = 0; i < schemata.length; ++i) {\n                subProps    = schemata[i].schema._properties;\n                subSchemata = schemata[i].schema._schemata;\n\n                // This sub schemata hasn't been encountered yet.\n                if (doc[schemata[i].propertyName] === undefined) {\n                    if (schemata[i].relationshipType === Schema.RELATIONSHIP_TYPE.SINGLE)\n                        doc[schemata[i].propertyName] = {};\n                    else\n                        doc[schemata[i].propertyName] = [];\n                }\n\n                // Recurse and serialize the sub schemata.  Note that the lookup for each\n                // schema needs to be unique because there could be two schemata at the\n                // same level that have key columns with the same value (e.g. a person with\n                // product and phone numbers, and phoneNumberID = 1 and productID = 1).\n                if (lookup[keyVal].lookup[schemata[i].propertyName] === undefined)\n                    lookup[keyVal].lookup[schemata[i].propertyName] = {};\n\n                serializeRow(queryRow, schemata[i].schema, doc[schemata[i].propertyName],\n                             subProps, lookup[keyVal].lookup[schemata[i].propertyName], subSchemata,\n                             schemata[i].relationshipType);\n            }\n        }\n\n        // Serialize each row recursively.\n        for (let i = 0; i < query.length; ++i) {\n            serializeRow(query[i], schema, collection, schema._properties, lookup,\n                         schema._schemata, Schema.RELATIONSHIP_TYPE.MANY);\n        }\n\n        return collection;\n    }\n}\n"],"file":"DataMapper.js"}