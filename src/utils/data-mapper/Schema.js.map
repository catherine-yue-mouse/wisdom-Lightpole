{"version":3,"sources":["data-mapper/Schema.js"],"names":["Schema","keyColumnName","propertyName","convert","_keyColumnName","_properties","_schemata","_propertyLookup","addProperty","columnName","dm_assert","undefined","push","propertyNames","Array","prototype","slice","call","arguments","i","length","schema","relationshipType","RELATIONSHIP_TYPE","MANY","SINGLE"],"mappings":";;;;;;;;AAAA;;;;IAIMA,M;;;AACF;;;;;;;;;;;AAWA,kBAAYC,aAAZ,EAA2BC,YAA3B,EAAyCC,OAAzC,EAAkD;AAAA;;AAC9C;AACA;AACA,SAAKC,cAAL,GAAsBH,aAAtB;AACA,SAAKI,WAAL,GAAsB,EAAtB;AACA,SAAKC,SAAL,GAAsB,EAAtB,CAL8C,CAO9C;AACA;;AACA,SAAKC,eAAL,GAAuB,EAAvB;AAEA,SAAKC,WAAL,CAAiBP,aAAjB,EAAgCC,YAAhC,EAA8CC,OAA9C;AACH;AAED;;;;;;;;uCAImB;AACf,aAAO,KAAKC,cAAZ;AACH;AAED;;;;;;;;;;;;gCASYK,U,EAAYP,Y,EAAcC,O,EAAS;AAC3CD,MAAAA,YAAY,GAAGA,YAAY,IAAIO,UAA/B,CAD2C,CAG3C;;AACAC,MAAAA,SAAS,CAAC,KAAKH,eAAL,CAAqBL,YAArB,MAAuCS,SAAxC,uBACWT,YADX,mCAAT;AAGA,WAAKK,eAAL,CAAqBL,YAArB,IAAqC,IAArC;;AACA,WAAKG,WAAL,CAAiBO,IAAjB,CAAsB;AAClBV,QAAAA,YAAY,EAAEA,YADI;AAElBO,QAAAA,UAAU,EAAIA,UAFI;AAGlBN,QAAAA,OAAO,EAAOA;AAHI,OAAtB;;AAMA,aAAO,IAAP;AACH;AAED;;;;;;;;;kCAMcU,a,EAAe;AACzB;AACA,UAAI,EAAEA,aAAa,YAAYC,KAA3B,CAAJ,EACID,aAAa,GAAGC,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,CAAhB;;AAEJ,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,aAAa,CAACO,MAAlC,EAA0C,EAAED,CAA5C;AACI,aAAKX,WAAL,CAAiBK,aAAa,CAACM,CAAD,CAA9B;AADJ;;AAGA,aAAO,IAAP;AACH;AAED;;;;;;;;;oCAMgB;AACZ,aAAO,KAAKd,WAAZ;AACH;AAED;;;;;;;;;;;;;8BAUUH,Y,EAAcmB,M,EAAQC,gB,EAAkB;AAC9C;AACAZ,MAAAA,SAAS,CAAC,KAAKH,eAAL,CAAqBL,YAArB,MAAuCS,SAAxC,uBACWT,YADX,mCAAT;AAGA,WAAKK,eAAL,CAAqBL,YAArB,IAAqC,IAArC;;AAEA,WAAKI,SAAL,CAAeM,IAAf,CAAoB;AAChBV,QAAAA,YAAY,EAAMA,YADF;AAEhBmB,QAAAA,MAAM,EAAYA,MAFF;AAGhBC,QAAAA,gBAAgB,EAAEA,gBAAgB,IAAItB,MAAM,CAACuB,iBAAP,CAAyBC;AAH/C,OAApB;;AAMA,aAAO,IAAP;AACH;AAED;;;;;;;;;kCAMc;AACV,aAAO,KAAKlB,SAAZ;AACH;;;;;AAGL;;;;;;;;;;AAQAN,MAAM,CAACuB,iBAAP,GAA2B;AAACC,EAAAA,IAAI,EAAE,MAAP;AAAeC,EAAAA,MAAM,EAAE;AAAvB,CAA3B","sourcesContent":["/** A Schema is a representation of a serializable database table, consisting\n * of a series of columns.  Each column may be provided a property name\n * (mapping), which is the name that the column will be serialized as in the\n * resulting object. */\nclass Schema {\n    /**\n     * Initialize the Schema instance.\n     * @param {string} keyColumnName - The name of the unique key column,\n     * generally the primary key.\n     * @param {string} propertyName - An optional mapping for the key column.\n     * Defaults to the same name as the key column.\n     * @param {function} convert - An optional convert function that takes in\n     * the value associated the key column and converts it.  For example, a\n     * function that converts a bit to a boolean, or a native Date object to a\n     * string.\n     */\n    constructor(keyColumnName, propertyName, convert) {\n        // Note that these properties are treated as package private.  The DataMapper\n        // accesses them directly for efficiency reasons.\n        this._keyColumnName = keyColumnName;\n        this._properties    = [];\n        this._schemata      = [];\n\n        // An object is used instead of a Map because it performs better,\n        // especially on gets, and performance is important here.\n        this._propertyLookup = {};\n\n        this.addProperty(keyColumnName, propertyName, convert);\n    }\n\n    /**\n     * Get the name of the key column.\n     * @return {string} The name of the key column.\n     */\n    getKeyColumnName() {\n        return this._keyColumnName;\n    }\n\n    /**\n     * Add a property to the schema.\n     * @param {string} columnName - The name of the database column.\n     * @param {string} propertyNamea - The name of the property in the\n     * resulting object.  Defaults to the property name.\n     * @param {function} convert - An optional convert function that takes in\n     * the value associated the column and converts it.\n     * @return {this}\n     */\n    addProperty(columnName, propertyName, convert) {\n        propertyName = propertyName || columnName;\n\n        // The property names must be unique.\n        dm_assert(this._propertyLookup[propertyName] === undefined,\n               `Property \"${propertyName}\" already present in schema.`);\n\n        this._propertyLookup[propertyName] = true;\n        this._properties.push({\n            propertyName: propertyName,\n            columnName:   columnName,\n            convert:      convert\n        });\n\n        return this;\n    }\n\n    /**\n     * Short-hand notation for adding properties.  An array can be used, or a\n     * series of strings (variadic).\n     * @param {string[]} propertyNames - An array of property names.\n     * @return {this}\n     */\n    addProperties(propertyNames) {\n        // If passed variadically convert the arguments to an array.\n        if (!(propertyNames instanceof Array))\n            propertyNames = Array.prototype.slice.call(arguments);\n\n        for (let i = 0; i < propertyNames.length; ++i)\n            this.addProperty(propertyNames[i]);\n\n        return this;\n    }\n\n    /**\n     * Get the array of properties.  Each property has the column name and the\n     * property name.\n     * @return {Object[]} An array of properties, each with a propertyName,\n     * columnName, and convert function.\n     */\n    getProperties() {\n        return this._properties;\n    }\n\n    /**\n     * Add a sub schema, which is a related table and will be nested under this\n     * schema using propertyName.\n     * @param {string} propertyName - The name of the sub schema property.\n     * @param {Schema} schema - A Schema instance.\n     * @param {Schema.RELATIONSHIP_TYPE} relationshipType - The type of\n     * relationship, either single (object) or many (array).  Defaults to\n     * Schema.RELATIONSHIP_TYPE.MANY.\n     * @return {this}\n     */\n    addSchema(propertyName, schema, relationshipType) {\n        // The property names must be unique.\n        dm_assert(this._propertyLookup[propertyName] === undefined,\n               `Property \"${propertyName}\" already present in schema.`);\n\n        this._propertyLookup[propertyName] = true;\n\n        this._schemata.push({\n            propertyName:     propertyName,\n            schema:           schema,\n            relationshipType: relationshipType || Schema.RELATIONSHIP_TYPE.MANY\n        });\n\n        return this;\n    }\n\n    /**\n     * Get the array of schemata, each of which has a property name and a Schema\n     * instance.\n     * @return {Object[]} An array of objects, each with a property name and\n     * a Schema instance.\n     */\n    getSchemata() {\n        return this._schemata;\n    }\n}\n\n/**\n * @typedef Schema.RELATIONSHIP_TYPE\n * @constant\n * @static\n * @type {Object}\n * @property {string} MANY - Map to an array.\n * @property {string} SINGLE - Map to an object.\n */\nSchema.RELATIONSHIP_TYPE = {MANY: 'many', SINGLE: 'single'};\n"],"file":"Schema.js"}